#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <strings.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <ctype.h>


#define MAXLINE         4096    /* max text line length */
#define DAYTIME_PORT    3333
#define BUFFER_SIZE     1024


int main(int argc, char **argv)
{
    int     sockfd;
    int     n;
    int     serverPort, tunnelPort;
    char    recvline[MAXLINE + 1];
    char    serverIPAddr[BUFFER_SIZE];
    char    tunnelIPAddr[BUFFER_SIZE];
    char    ipaddr[100];
    struct sockaddr_in servaddr, tunneladdr;
    
    

    // perform argument check
    if (argc < 3 || argc > 5) 
    {
        if (argc == 4)
            printf("usage: client <serverName> <server port number> or\n \
            client <tunnelName or tunnelIP> <tunnel port Number> <serverName or serverIP> <server port number>");
        exit(1);
    }
    
    
    
    
    // if everything is ok, do the following

    // create TCP socket
    if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
    {
        printf("socket error\n");
        exit(1);
    }
    
    
    if (argc == 3)  // if no tunnel arguments
    {
        // Specify server address and port number.
        // Reverse lookup server ip address
        // and convert IPv4 dotted decimal address to binary, then 
        // store in servaddr.sin_addr pointer
        bzero(&servaddr, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_port = htons(atoi(argv[2]));  // convert port number to big endian order
        

        char* testval = argv[1];
        if ( isdigit(testval[0]) )    // if first character is a number
        {
            // translate ip address from decimal to binary 
            if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
            {
                printf("inet_pton error for %s\n", argv[1]);
                exit(1);
            }

            // converts ip to machine name
            if ( getnameinfo((struct sockaddr *) &servaddr, sizeof(servaddr),
                serverIPAddr, sizeof(serverIPAddr), NULL, 0, 0) != 0 )
            {
                printf("reverse lookup failed\n");
                exit(1);
                
            }
           
            
            // print name and ip address of server
            printf("Client Side\n");
            printf("------------------------------------------------------\n");
            printf("Server Name: %s\n", serverIPAddr);
            printf("Server IP Address: %s\n", argv[1]); 
        }



        else if ( isalpha(testval[0]) ) // if first character is an alphabet
        {
            // convert machine name to ip address
            struct addrinfo hints, *result, *node;
            struct sockaddr_in *h;
            
            
            bzero(&hints, sizeof(hints));
            hints.ai_family = AF_INET;
            hints.ai_socktype = SOCK_STREAM;
            if ( getaddrinfo(argv[1], argv[2], &hints, &result) != 0 )
            {
                printf("reverse lookup failed\n");
                exit(1);
            }
            
            
            for (node = result; node != NULL; node = node->ai_next)
            {
                h = (struct sockaddr_in *) node->ai_addr;
                
                // convert ip address from binary to decimal, 
                // then copy to buffer ip
                strcpy(ipaddr, inet_ntoa(h->sin_addr) );
            }
            
            // print name and ip address of server
            printf("Client Side\n");
            printf("------------------------------------------------------\n");
            printf("Server Name: %s\n", argv[1]);
            printf("Server IP Address: %s\n", ipaddr);
            
            freeaddrinfo(result);
        }

    

        
        // establish TCP connection
        if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
        {
            printf("connect error\n");
            exit(1);
        }
        
        
        // receive stuff
        while ( (n = read(sockfd, recvline, MAXLINE)) > 0) 
        {
            recvline[n] = 0;        /* null terminate */
            if (fputs(recvline, stdout) == EOF) 
            {
                    printf("fputs error\n");
                    exit(1);
            }
        } 
        
    }
    
    
    else  // if tunnel arguments exist, i.e. argvc == 5
    {
        // Specify server address and port number.
        // Reverse lookup server ip address
        // and convert IPv4 dotted decimal address to binary, then 
        // store in servaddr.sin_addr pointer
        bzero(&tunneladdr, sizeof(tunneladdr));
        tunneladdr.sin_family = AF_INET;
        tunneladdr.sin_port = htons(atoi(argv[2]));  // convert port number to big endian order
        

        char* testval = argv[1];
        if ( isdigit(testval[0]) )    // if first character is a number
        {
            // translate ip address from decimal to binary 
            if (inet_pton(AF_INET, argv[1], &tunneladdr.sin_addr) <= 0)
            {
                printf("inet_pton error for %s\n", argv[1]);
                exit(1);
            }

            // converts ip to machine name
            if ( getnameinfo((struct sockaddr *) &tunneladdr, sizeof(tunneladdr),
                tunnelIPAddr, sizeof(tunnelIPAddr), NULL, 0, 0) != 0 )
            {
                printf("reverse lookup failed\n");
                exit(1);
                
            }
           
            
            // print name and ip address of server
            printf("Client Side\n");
            printf("------------------------------------------------------\n");
            printf("Tunnel Name: %s\n", tunnelIPAddr);
            printf("Tunnel IP Address: %s\n", argv[1]); 
        }



        else if ( isalpha(testval[0]) ) // if first character is an alphabet
        {
            // convert machine name to ip address
            struct addrinfo hints, *result, *node;
            struct sockaddr_in *h;
            
            
            bzero(&hints, sizeof(hints));
            hints.ai_family = AF_INET;
            hints.ai_socktype = SOCK_STREAM;
            if ( getaddrinfo(argv[1], argv[2], &hints, &result) != 0 )
            {
                printf("reverse lookup failed\n");
                exit(1);
            }
            
            
            for (node = result; node != NULL; node = node->ai_next)
            {
                h = (struct sockaddr_in *) node->ai_addr;
                
                // convert ip address from binary to decimal, 
                // then copy to buffer ip
                strcpy(ipaddr, inet_ntoa(h->sin_addr) );
            }
            
            // print name and ip address of server
            printf("Client Side\n");
            printf("------------------------------------------------------\n");
            printf("Tunnel Name: %s\n", argv[1]);
            printf("Tunnel IP Address: %s\n", ipaddr);
            
            freeaddrinfo(result);
        }

    

        
        // establish TCP connection
        if (connect(sockfd, (struct sockaddr *) &tunneladdr, sizeof(tunneladdr)) < 0)
        {
            printf("connect error\n");
            exit(1);
        }
        
        
        // receive stuff
        while ( (n = read(sockfd, recvline, MAXLINE)) > 0) 
        {
            recvline[n] = 0;        /* null terminate */
            if (fputs(recvline, stdout) == EOF) 
            {
                    printf("fputs error\n");
                    exit(1);
            }
        } 
        

    }
       
  
  
        
    if (n < 0) 
    {
        printf("read error\n");
        exit(1);
    }    
     

    
    exit(0);
}

